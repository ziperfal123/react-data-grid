{"version":3,"file":"useViewportRows.js","sourceRoot":"","sources":["../../src/hooks/useViewportRows.ts"],"names":[],"mappings":"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","sourcesContent":["import { useMemo } from 'react';\n\nimport { GroupRow, GroupByDictionary, Dictionary } from '../types';\nconst RENDER_BACTCH_SIZE = 8;\n\ninterface ViewportRowsArgs<R> {\n  rawRows: readonly R[];\n  rowHeight: number;\n  clientHeight: number;\n  scrollTop: number;\n  groupBy: readonly string[];\n  rowGrouper?: (rows: readonly R[], columnKey: string) => Dictionary<readonly R[]>;\n  expandedGroupIds?: ReadonlySet<unknown>;\n}\n\nexport function useViewportRows<R>({\n  rawRows,\n  rowHeight,\n  clientHeight,\n  scrollTop,\n  groupBy,\n  rowGrouper,\n  expandedGroupIds\n}: ViewportRowsArgs<R>) {\n  const [groupedRows, rowsCount] = useMemo(() => {\n    if (groupBy.length === 0 || !rowGrouper) return [undefined, rawRows.length];\n\n    const groupRows = (rows: readonly R[], [groupByKey, ...remainingGroupByKeys]: readonly string[], startRowIndex: number): [GroupByDictionary<R>, number] => {\n      let groupRowsCount = 0;\n      const groups: GroupByDictionary<R> = {};\n      for (const [key, childRows] of Object.entries(rowGrouper(rows, groupByKey))) {\n        // Recursively group each parent group\n        const [childGroups, childRowsCount] = remainingGroupByKeys.length === 0\n          ? [childRows, childRows.length]\n          : groupRows(childRows, remainingGroupByKeys, startRowIndex + groupRowsCount + 1); // 1 for parent row\n        groups[key] = { childRows, childGroups, startRowIndex: startRowIndex + groupRowsCount };\n        groupRowsCount += childRowsCount + 1; // 1 for parent row\n      }\n\n      return [groups, groupRowsCount];\n    };\n\n    return groupRows(rawRows, groupBy, 0);\n  }, [groupBy, rowGrouper, rawRows]);\n\n  const [rows, allGroupRows] = useMemo(() => {\n    const allGroupRows = new Set<unknown>();\n    if (!groupedRows) return [rawRows, allGroupRows];\n\n    const flattenedRows: Array<R | GroupRow<R>> = [];\n    const expandGroup = (rows: GroupByDictionary<R> | readonly R[], parentId: string | undefined, level: number): void => {\n      if (Array.isArray(rows)) {\n        flattenedRows.push(...rows);\n        return;\n      }\n      Object.keys(rows).forEach((groupKey, posInSet, keys) => {\n        // TODO: should users have control over the generated key?\n        const id = parentId !== undefined ? `${parentId}__${groupKey}` : groupKey;\n        const isExpanded = expandedGroupIds?.has(id) ?? false;\n        const { childRows, childGroups, startRowIndex } = (rows as GroupByDictionary<R>)[groupKey]; // https://github.com/microsoft/TypeScript/issues/17002\n\n        const groupRow: GroupRow<R> = {\n          id,\n          parentId,\n          groupKey,\n          isExpanded,\n          childRows,\n          level,\n          posInSet,\n          startRowIndex,\n          setSize: keys.length\n        };\n        flattenedRows.push(groupRow);\n        allGroupRows.add(groupRow);\n\n        if (isExpanded) {\n          expandGroup(childGroups, id, level + 1);\n        }\n      });\n    };\n\n    expandGroup(groupedRows, undefined, 0);\n    return [flattenedRows, allGroupRows];\n  }, [expandedGroupIds, groupedRows, rawRows]);\n\n  const isGroupRow = <R>(row: unknown): row is GroupRow<R> => allGroupRows.has(row);\n\n  const overscanThreshold = 4;\n  const rowVisibleStartIdx = Math.floor(scrollTop / rowHeight);\n  const rowVisibleEndIdx = Math.min(rows.length - 1, Math.floor((scrollTop + clientHeight) / rowHeight));\n  const rowOverscanStartIdx = Math.max(0, Math.floor((rowVisibleStartIdx - overscanThreshold) / RENDER_BACTCH_SIZE) * RENDER_BACTCH_SIZE);\n  const rowOverscanEndIdx = Math.min(rows.length - 1, Math.ceil((rowVisibleEndIdx + overscanThreshold) / RENDER_BACTCH_SIZE) * RENDER_BACTCH_SIZE);\n\n  return {\n    rowOverscanStartIdx,\n    rowOverscanEndIdx,\n    rows,\n    rowsCount,\n    isGroupRow\n  };\n}\n"]}