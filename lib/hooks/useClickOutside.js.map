{"version":3,"file":"useClickOutside.js","sourceRoot":"","sources":["../../src/hooks/useClickOutside.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,OAAO,CAAC;AAE1C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+CG;AAEH,MAAM,UAAU,eAAe,CAAC,OAAmB;IACjD,MAAM,eAAe,GAAG,MAAM,EAAsB,CAAC;IAErD,SAAS,2BAA2B;QAClC,IAAI,OAAO,eAAe,CAAC,OAAO,KAAK,QAAQ,EAAE;YAC/C,oBAAoB,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC;YAC9C,eAAe,CAAC,OAAO,GAAG,SAAS,CAAC;SACrC;IACH,CAAC;IAED,0EAA0E;IAC1E,oEAAoE;IACpE,qEAAqE;IACrE,MAAM,UAAU,GAAG,MAAM,CAAC,GAAS,EAAE;QACnC,MAAM,IAAI,KAAK,CAAC,+CAA+C,CAAC,CAAC;IACnE,CAAC,CAAC,CAAC;IAEH,SAAS,CAAC,GAAG,EAAE;QACb,UAAU,CAAC,OAAO,GAAG,OAAO,CAAC;IAC/B,CAAC,CAAC,CAAC;IAEH,SAAS,CAAC,GAAG,EAAE;QACb,SAAS,cAAc;YACrB,eAAe,CAAC,OAAO,GAAG,SAAS,CAAC;YACpC,UAAU,CAAC,OAAO,EAAE,CAAC;QACvB,CAAC;QAED,SAAS,oBAAoB;YAC3B,2BAA2B,EAAE,CAAC;YAC9B,eAAe,CAAC,OAAO,GAAG,qBAAqB,CAAC,cAAc,CAAC,CAAC;QAClE,CAAC;QAED,MAAM,CAAC,gBAAgB,CAAC,OAAO,EAAE,oBAAoB,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC;QAE1E,OAAO,GAAG,EAAE;YACV,MAAM,CAAC,mBAAmB,CAAC,OAAO,EAAE,oBAAoB,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC;YAC7E,2BAA2B,EAAE,CAAC;QAChC,CAAC,CAAC;IACJ,CAAC,EAAE,EAAE,CAAC,CAAC;IAEP,OAAO,2BAA2B,CAAC;AACrC,CAAC","sourcesContent":["import { useRef, useEffect } from 'react';\n\n/**\n * Detecting outside click on a react component is surprisingly hard.\n * A general approach is to have a global click handler on the document\n * which checks if the click target is inside the editor container or\n * not using editorContainer.contains(e.target). This approach works well\n * until portals are used for editors. Portals render children into a DOM\n * node that exists outside the DOM hierarchy of the parent component so\n * editorContainer.contains(e.target) does not work. Here are some examples\n * of the DOM structure with different types of editors\n *\n *\n * SimpleEditor for example Texbox (No Portals)\n *   <div data-grid>..</div>\n *   <div portal-created-by-the-grid-for-editors>\n *      <div editor-container>\n *        <div simple-editor>..</div>\n *      </div>\n *   </div>\n *\n * ComplexEditor for example Modals (using Portals)\n *   <div data-grid>..</div>\n *   <div portal-created-by-the-grid-for-editors>\n *      <div editor-container>\n *        // Nothing here\n *      </div>\n *   </div>\n *   <div portal-created-by-the-editor>\n *     <div complex-editor>..</div>\n *   </div>\n *\n *\n * One approach to detect outside click is to use synthetic event bubbling through\n * portals. An event fired from inside a portal will propagate to ancestors\n * in the containing React tree, even if those elements are not ancestors\n * in the DOM tree. This means a click handler can be attached on the window\n * and on the editor container. The editor container can set a flag to notify\n * that the click was inside the editor and the window click handler can use\n * this flag to call onClickOutside. This approach however has a few caveats\n * - Click handler on the window is set using window.addEventListener\n * - Click handler on the editor container is set using onClick prop\n *\n * This means if a child component inside the editor calls e.stopPropagation\n * then the click handler on the editor container will not be called whereas\n * the document click handler will be called.\n * https://github.com/facebook/react/issues/12518\n *\n * To solve this issue onClickCapture event is used.\n */\n\nexport function useClickOutside(onClick: () => void) {\n  const frameRequestRef = useRef<number | undefined>();\n\n  function cancelAnimationFrameRequest() {\n    if (typeof frameRequestRef.current === 'number') {\n      cancelAnimationFrame(frameRequestRef.current);\n      frameRequestRef.current = undefined;\n    }\n  }\n\n  // We need to prevent the `useEffect` from cleaning up between re-renders,\n  // as `handleDocumentClick` might otherwise miss valid click events.\n  // To that end we instead access the latest `onClick` prop via a ref.\n  const onClickRef = useRef((): void => {\n    throw new Error('Cannot call an event handler while rendering.');\n  });\n\n  useEffect(() => {\n    onClickRef.current = onClick;\n  });\n\n  useEffect(() => {\n    function onOutsideClick() {\n      frameRequestRef.current = undefined;\n      onClickRef.current();\n    }\n\n    function onWindowCaptureClick() {\n      cancelAnimationFrameRequest();\n      frameRequestRef.current = requestAnimationFrame(onOutsideClick);\n    }\n\n    window.addEventListener('click', onWindowCaptureClick, { capture: true });\n\n    return () => {\n      window.removeEventListener('click', onWindowCaptureClick, { capture: true });\n      cancelAnimationFrameRequest();\n    };\n  }, []);\n\n  return cancelAnimationFrameRequest;\n}\n"]}